(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[405],{5557:function(n,e,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/",function(){return t(8094)}])},8094:function(n,e,t){"use strict";t.r(e),t.d(e,{default:function(){return G}});var r=t(4051),a=t.n(r),l=t(5893),o=t(6306),u=t(2959),s=t(1889),_=t(8504),d=t(6713),c=t(4842),p=t(882),m={basic:{expr2:"program expr2\n    implicit none\n\n    integer :: x\n\n    x = (2+3)*5\n    print *, x\nend program",mandelbrot:'program mandelbrot\n    integer, parameter :: Nx = 600, Ny = 450, n_max = 255, dp=kind(0.d0)\n    real(dp), parameter :: xcenter = -0.5_dp, ycenter = 0.0_dp, &\n        width = 4, height = 3, dx_di = width/Nx, dy_dj = -height/Ny, &\n        x_offset = xcenter - (Nx+1)*dx_di/2, y_offset = ycenter - (Ny+1)*dy_dj/2\n    integer :: image(Nx,Ny), image_color(4,Nx,Ny), palette(3,4), i, j, n, idx\n    real(dp) :: x, y, x_0, y_0, x_sqr, y_sqr\n    interface\n        subroutine show_img(w, h, A) bind(c)\n        integer, intent(in) :: w, h\n        integer, intent(in) :: A(w,h)\n        end subroutine\n        subroutine show_img_color(w, h, A) bind(c)\n        integer, intent(in) :: w, h\n        integer, intent(in) :: A(4,w,h)\n        end subroutine\n    end interface\n    do j = 1, Ny\n        y_0 = y_offset + dy_dj * j\n        do i = 1, Nx\n            x_0 = x_offset + dx_di * i\n            x = 0; y = 0; n = 0\n            do\n                x_sqr = x ** 2; y_sqr = y ** 2\n                if (x_sqr + y_sqr > 4 .or. n == n_max) then\n                    image(i,j) = 255-n\n                    exit\n                end if\n                y = y_0 + 2 * x * y\n                x = x_0 + x_sqr - y_sqr\n                n = n + 1\n            end do\n        end do\n    end do\n    palette(1,1) =   0; palette(2,1) = 135; palette(3,1) =  68\n    palette(1,2) =   0; palette(2,2) =  87; palette(3,2) = 231\n    palette(1,3) = 214; palette(2,3) =  45; palette(3,3) =  32\n    palette(1,4) = 255; palette(2,4) = 167; palette(3,4) =   0\n    do j = 1, Ny\n        do i = 1, Nx\n            idx = image(i,j) - (image(i,j)/4)*4 + 1\n            image_color(1,i,j) = palette(1,idx) ! Red\n            image_color(2,i,j) = palette(2,idx) ! Green\n            image_color(3,i,j) = palette(3,idx) ! Blue\n            image_color(4,i,j) = 255            ! Alpha\n        end do\n    end do\n    print *, "The Mandelbrot image in color:"\n    call show_img_color(Nx, Ny, image_color)\n    print *, "The Mandelbrot image in grayscale:"\n    call show_img(Nx, Ny, image)\n    print *, "Done."\nend program mandelbrot'},experimental:{template_add:'module template_add_m\n    implicit none\n    private\n    public :: add_t\n\n    requirement R(T, F)\n        type :: T; end type\n        function F(x, y) result(z)\n            type(T), intent(in) :: x, y\n            type(T) :: z\n        end function\n    end requirement\n\n    template add_t(T, F)\n        requires R(T, F)\n        private\n        public :: add_generic\n    contains\n        function add_generic(x, y) result(z)\n            type(T), intent(in) :: x, y\n            type(T) :: z\n            z = F(x, y)\n        end function\n    end template\n\ncontains\n\n    real function func_arg_real(x, y) result(z)\n        real, intent(in) :: x, y\n        z = x + y\n    end function\n\n    integer function func_arg_int(x, y) result(z)\n        integer, intent(in) :: x, y\n        z = x + y\n    end function\n\n    subroutine test_template()\n        instantiate add_t(real, func_arg_real), only: add_real => add_generic\n        real :: x, y\n        integer :: a, b\n        x = 5.1\n        y = 7.2\n        print*, "The result is ", add_real(x, y)\n        if (abs(add_real(x, y) - 12.3) > 1e-5) error stop\n\n        instantiate add_t(integer, func_arg_int), only: add_integer => add_generic\n        a = 5\n        b = 9\n        print*, "The result is ", add_integer(a, b)\n        if (add_integer(a, b) /= 14) error stop\n    end subroutine\nend module\n\nprogram template_add\nuse template_add_m\nimplicit none\n\ncall test_template()\n\nend program template_add',template_nested:'module template_nested_m\n    implicit none\n    private\n    public :: add_t\n\n    requirement R(T, F)\n        type :: T; end type\n        function F(x, y) result(z)\n            type(T), intent(in) :: x, y\n            type(T) :: z\n        end function\n    end requirement\n\n    template add_t(T, F)\n        requires R(T, F)\n        private\n        public :: add_generic\n    contains\n        function add_generic(x, y) result(z)\n            type(T), intent(in) :: x, y\n            type(T) :: z\n            z = F(x, y)\n        end function\n        function call_add_generic(x, y) result(z)\n            type(T), intent(in) :: x, y\n            type(T) :: z\n            z = add_generic(x, y)\n        end function\n    end template\n\ncontains\n\n    real function func_arg_real(x, y) result(z)\n        real, intent(in) :: x, y\n        z = x + y\n    end function\n\n    subroutine test_template()\n        instantiate add_t(real, func_arg_real), only: add_real => call_add_generic\n        real :: x, y\n        integer :: a, b\n        x = 5.1\n        y = 7.2\n        print*, "The result is ", add_real(x, y)\n        if (abs(add_real(x, y) - 12.3) > 1e-5) error stop\n    end subroutine\nend module\n\nprogram template_nested\nuse template_nested_m\nimplicit none\n\ncall test_template()\n\nend program template_nested',template_travel:'module math\n\n    implicit none\n    private\n    public :: add_real, slash_real\n\ncontains\n\n    pure function add_real(x, y) result(total)\n        real, intent(in) :: x, y\n        real :: total\n        total = x + y\n    end function\n\n    pure function slash_real(x, y) result(total)\n        real, intent(in) :: x, y\n        real :: total\n        total = x / y\n    end function\n\nend module\n\nmodule travel\n\n    use math\n    implicit none\n    private \n    public :: travel_tmpl\n\n    requirement operations(D, T, S, plus_D, plus_T, D_divided_by_T, D_divided_by_S)\n        type :: D; end type\n        type :: T; end type\n        type :: S; end type\n\n        pure function plus_D(l, r) result(total)\n            type(D), intent(in) :: l, R\n            type(D) :: total\n        end function\n\n        pure function plus_T(l, r) result(total)\n            type(T), intent(in) :: l, R\n            type(T) :: total\n        end function\n\n        pure function D_divided_by_T(n, d) result(quotient)\n            type(D), intent(in) :: n\n            type(T), intent(in) :: d\n            type(S) :: quotient\n        end function\n\n        pure function D_divided_by_S(n, d) result(quotient)\n            type(D), intent(in) :: n\n            type(S), intent(in) :: d\n            type(T) :: quotient\n        end function\n    end requirement\n\n    template travel_tmpl(D, T, S, plus_D, plus_T, D_divided_by_T, D_divided_by_S)\n        requires operations(D, T, S, plus_D, plus_T, D_divided_by_T, D_divided_by_S)\n        private\n        public :: avg_S_from_T\n    contains\n        pure function avg_S_from_T(d1, t1, d2, t2) result(avg)\n            type(D), intent(in) :: d1, d2\n            type(T), intent(in) :: t1, t2\n            type(S) :: avg\n            avg = D_divided_by_T(plus_D(d1, d2), plus_T(t1, t2))\n        end function\n        \n        pure function avg_S_from_S(d1, s1, d2, s2) result(avg)\n            type(D), intent(in) :: d1, d2\n            type(S), intent(in) :: s1, s2\n            type(S) :: avg\n            avg = avg_S_from_T(d1, D_divided_by_S(d1, s1), d2, D_divided_by_S(d2, s2))\n        end function\n    end template\n\nend module\n\nmodule template_travel_m\n\n    use math\n    use travel\n    implicit none\n\ncontains\n\n    subroutine test_template()\n        instantiate travel_tmpl(real, real, real, add_real, add_real, slash_real, slash_real), &\n            only: avg_real_S_from_T => avg_S_from_T\n        instantiate travel_tmpl(real, real, real, add_real, add_real, slash_real, slash_real), &\n            only: avg_real_S_from_S => avg_S_from_S\n        real :: s1, s2\n        s1 = avg_real_S_from_T(1.0, 3.0, 1.5, 4.0)\n        s2 = avg_real_S_from_S(1.1, 0.5, 2.0, 0.75)\n        print *, "s1=", s1\n        print *, "s2=", s2\n    end subroutine\n\nend module\n\nprogram template_travel\nuse template_travel_m\nimplicit none\n\ncall test_template()\n\nend program template_travel',template_triple:'module Math_integer_m\n\n    implicit none\n    private\n    public :: add_integer\n  \n  contains\n  \n    pure function add_integer(x, y) result(result)\n      integer, intent(in) :: x, y\n      integer :: result\n      result = x + y\n    end function\n  \n    pure function minus_integer(x, y) result(result)\n      integer, intent(in) :: x, y\n      integer :: result\n      result = x - y\n    end function\n  \n    pure function max_integer(x, y) result(result)\n      integer, intent(in) :: x, y\n      integer :: result\n      result = max(x, y)\n    end function\n  \n    pure function min_integer(x, y) result(result)\n      integer, intent(in) :: x, y\n      integer :: result\n      result = min(x, y)\n    end function\n  \n    pure function zero_integer() result(result)\n      integer :: result\n      result = 0\n    end function\n  \n    pure function one_integer() result(result)\n      integer :: result\n      result = 1\n    end function\n  \n  end module\n  \n  module Math_real_m\n  \n    implicit none\n    private\n    public :: add_real\n  \n  contains\n  \n    pure function add_real(x, y) result(result)\n      real, intent(in) :: x, y\n      real :: result\n      result = x + y\n    end function\n  \n    pure function minus_real(x, y) result(result)\n      real, intent(in) :: x, y\n      real :: result\n      result = x - y\n    end function\n  \n    pure function slash_real(x, y) result(result)\n      real, intent(in) :: x, y\n      real :: result\n      result = x / y\n    end function\n  \n    pure function max_real(x, y) result(result)\n      real, intent(in) :: x, y\n      real :: result\n      result = max(x, y)\n    end function\n  \n    pure function min_real(x, y) result(result)\n      real, intent(in) :: x, y\n      real :: result\n      result = min(x, y)\n    end function\n  \n    pure function zero_real() result(result)\n      real :: result\n      result = 0.0\n    end function\n  \n    pure function one_real() result(result)\n      real :: result\n      result = 1.0\n    end function\n  \n  end module\n  \n  module triple_m\n  \n    implicit none\n    private\n    public :: triple_tmpl\n  \n    requirement magma_r(T, plus_T)\n      type :: T; end type\n  \n      pure function plus_T(l, r) result(total)\n        type(T), intent(in) :: l, r\n        type(T) :: total\n      end function\n    end requirement\n  \n    template triple_tmpl(T, plus_T)\n      requires magma_r(T, plus_T)\n      private\n      public :: triple_l, triple_r\n    contains\n      pure function triple_l(t) result(result)\n        type(T), intent(in) :: t\n        type(T) :: result\n        result = plus_T(plus_T(t, t), t)\n      end function\n      \n      pure function triple_r(t) result(result)\n        type(T), intent(in) :: t\n        type(T) :: result\n        result = plus_T(t, plus_T(t, t))\n      end function\n    end template\n  \n  end module\n  \n  module use_triple_m\n  \n    use Math_integer_m\n    use Math_real_m\n    use triple_m\n  \n  contains\n  \n    subroutine test_add_triples()\n      instantiate triple_tmpl(integer, add_integer), &\n        only: triple_add_l => triple_l, &\n              triple_add_r => triple_r\n      integer :: tal, tar\n      tal = triple_add_l(7)\n      tar = triple_add_r(7)\n      print *, "tal = ", tal, " tar = ", tar\n    end subroutine\n  \n    subroutine test_minus_triples()\n      instantiate triple_tmpl(real, minus_real), &\n        only: triple_minus_l => triple_l, &\n              triple_minus_r => triple_r\n      real :: tml, tmr\n      tml = triple_minus_l(7.0)\n      tmr = triple_minus_r(7.0)\n      print *, "tml = ", tml, " tmr = ", tmr\n    end subroutine\n  \n    subroutine test_max_triples()\n      instantiate triple_tmpl(real, max_real), &\n        only: triple_max_l => triple_l, &\n              triple_max_r => triple_r\n      real :: tmaxl, tmaxr\n      tmaxl = triple_max_l(7.0)\n      tmaxr = triple_max_r(7.0)\n      print *, "tmaxl =", tmaxl, " tmaxr =", tmaxr\n    end subroutine\n  \n  end module\n  \n  program template_triple\n  use use_triple_m\n  \n  call test_add_triples()\n  call test_minus_triples()\n  call test_max_triples()\n  \n  end program template_triple',template_array_01b:"module template_array_01b_m\n\n    implicit none\n    private\n    public :: test_template\n\n    requirement r(t)\n        type :: t; end type\n    end requirement\n\n    template array_tmpl(t)\n        requires r(t)\n        private\n        public :: insert_t\n    contains\n        function insert_t(n, lst, i) result(r)\n            integer, intent(in) :: n\n            type(t), intent(in) :: lst(n), i\n            type(t) :: r\n            lst(1) = i\n            r = lst(1)\n        end function\n    end template\n\ncontains\n\n    subroutine test_template()\n        instantiate array_tmpl(integer), only: insert_int => insert_t\n        integer :: a(1), i, r\n        a(1) = 0\n        i = 1\n        print *, a(1)\n        r = insert_int(size(a), a, i)\n        print *, a(1)\n    end subroutine\n\nend module\n\nprogram template_array_01b\n\n    use template_array_01b_m\n    implicit none\n\n    call test_template()\n\nend",template_array_02b:"module template_array_02b_math\n\n    implicit none\n    private\n    public :: add_integer, zero_integer, add_real, zero_real\n\ncontains\n\n    pure function add_integer(x, y) result(r)\n        integer, intent(in) :: x, y\n        integer :: r\n        r = x + y\n    end function\n\n    pure function zero_integer(x) result(r)\n        integer, intent(in) :: x\n        integer :: r\n        r = 0\n    end function\n\n    pure function add_real(x, y) result(r)\n        real, intent(in) :: x, y\n        real :: r\n        r = x + y\n    end function\n\n    pure function zero_real(x) result(r)\n        real, intent(in) :: x\n        real :: r\n        r = 0\n    end function\n\nend module\n\nmodule template_array_02b_m\n\n    use template_array_02b_math\n    implicit none\n    private\n    public :: test_template\n\n    requirement operations(t, plus_t, zero_t)\n        type :: t; end type\n\n        pure function plus_t(l, r) result(rs)\n            type(t), intent(in) :: l, r\n            type(t) :: rs\n        end function\n\n        pure function zero_t(l) result(rs)\n            type(t), intent(in) :: l\n            type(t) :: rs\n        end function\n    end requirement\n\n    template array_tmpl(t, plus_t, zero_t)\n        requires operations(t, plus_t, zero_t)\n        private\n        public :: mysum_t\n    contains\n        function mysum_t(n, a) result(r)\n            integer, intent(in) :: n\n            type(t), intent(in) :: a(n)\n            type(t) :: r\n            integer :: i\n            r = zero_t(a(1))\n            do i = 1, size(a)\n                r = plus_t(r, a(i))\n            end do\n        end function\n    end template\n\ncontains\n\n    subroutine test_template()\n        instantiate array_tmpl(integer, add_integer, zero_integer), only: mysum_integer => mysum_t\n        integer :: a(10), i, s\n        do i = 1, size(a)\n            a(i) = i\n        end do\n        s = mysum_integer(size(a), a)\n        print *, s\n    end subroutine\n\nend module\n\nprogram template_array_02b\n\n    use template_array_02b_m\n    implicit none\n\n    call test_template()\n\nend",template_array_03:"module math\n\n    implicit none\n    private\n    public :: add_integer, zero_integer, add_real, zero_real, mult_integer, mult_real\n\ncontains\n\n    pure function add_integer(x, y) result(r)\n        integer, intent(in) :: x, y\n        integer :: r\n        r = x + y\n    end function\n\n    pure function zero_integer(x) result(r)\n        integer, intent(in) :: x\n        integer :: r\n        r = 0\n    end function\n\n    pure function mult_integer(x, y) result(r)\n        integer, intent(in) :: x, y\n        integer :: r\n        r = x * y\n    end function\n\n    pure function add_real(x, y) result(r)\n        real, intent(in) :: x, y\n        real :: r\n        r = x + y\n    end function\n\n    pure function zero_real(x) result(r)\n        real, intent(in) :: x\n        real :: r\n        r = 0\n    end function\n\n    pure function mult_real(x, y) result(r)\n        real, intent(in) :: x, y\n        real :: r\n        r = x * y\n    end function\n\nend module\n\nmodule template_array_03_m\n\n    use math\n    implicit none\n    private\n    public :: test_template\n\n    requirement operations(t, plus_t, zero_t, mult_t)\n\n        type :: t; end type\n\n        pure function plus_t(l, r) result(result)\n            type(t), intent(in) :: l, r\n            type(t) :: result\n        end function\n\n        pure function zero_t(x) result(result)\n            type(t), intent(in) :: x\n            type(t) :: result\n        end function\n\n        pure function mult_t(l, r) result(result)\n            type(t), intent(in) :: l, r\n            type(t) :: result\n        end function\n\n    end requirement\n!\n    template array_tmpl(t, plus_t, zero_t, mult_t)\n\n        requires operations(t, plus_t, zero_t, mult_t)\n        private\n        public :: mymatmul_t\n\n    contains\n\n        subroutine mymatmul_t(i, j, k, a, b, r)\n            integer, parameter, intent(in) :: i, j, k\n            type(t), intent(in) :: a(i,j), b(j,k)\n            type(t) :: r(i,k)\n            integer, parameter :: x, y, z\n            type(t) :: elem\n            do x = 1, i\n                do z = 1, k\n                    elem = zero_t(a(1,1))\n                    do y = 1, j\n                        elem = plus_t(elem, mult_t(a(x,y), b(y,z)))\n                    end do\n                    r(x,z) = elem\n                end do\n            end do\n        end subroutine\n\n    end template\n\ncontains\n\n    subroutine test_template()\n        integer :: arr(2,2)\n        integer :: r(2,2)\n        arr(1,1) = 1\n        arr(1,2) = 1\n        arr(2,1) = 0\n        arr(2,2) = 1\n        instantiate array_tmpl(integer, add_integer, zero_integer, mult_integer), &\n            only: mymatmul_int => mymatmul_t\n        call mymatmul_int(2, 2, 2, arr, arr, r)\n        print *, r(1,1)\n        print *, r(1,2)\n        print *, r(2,1)\n        print *, r(2,2)\n    end subroutine\n\nend module\n\nprogram template_array_03\n\n    use template_array_03_m\n    implicit none\n\n    call test_template()\n\nend"}},y=t(5152),f=t.n(y),g=o.Z.TabPane,x=f()(Promise.all([t.e(281),t.e(275),t.e(286)]).then(t.bind(t,2286)),{loadableGenerated:{webpack:function(){return[2286]}},ssr:!1});var h=function(n){var e=function(n){var e=function(e){t.push({key:e,label:e,onClick:function(){i(m[n][e])}})},t=[];for(var r in m[n])e(r);h.push({key:n,label:n,children:t})},t=n.disabled,r=n.sourceCode,i=n.setSourceCode,a=n.activeTab,y=n.handleUserTabChange,f=n.myHeight,h=[];for(var b in m)e(b);var v=(0,l.jsx)(u.Z,{items:h}),T={right:(0,l.jsxs)(s.Z,{disabled:t,onClick:function(){return y(a)},children:[" ",(0,l.jsx)(c.Z,{})," Run "]}),left:(0,l.jsx)(_.Z,{overlay:v,trigger:"hover",children:(0,l.jsx)("a",{onClick:function(n){return n.preventDefault()},children:(0,l.jsxs)(d.Z,{style:{marginRight:"10px"},children:["Examples ",(0,l.jsx)(p.Z,{})]})})})};return(0,l.jsx)("div",{className:"card-container",style:{height:"100%"},children:(0,l.jsx)(o.Z,{tabBarExtraContent:T,style:{height:"100%"},children:(0,l.jsx)(g,{tab:"main.f90",style:{height:f},children:(0,l.jsx)(x,{sourceCode:r,setSourceCode:i})},"1")})})},b=t(7132),v=t(5439);var T,w=function(n){var e=n.activeTab,t=n.output,r=n.handleUserTabChange,i=n.myHeight;return(0,l.jsxs)("div",{className:"card-container",children:[(0,l.jsx)(v.Z,{block:!0,style:{margin:"6px 0px 22px 0px"},options:["STDOUT","AST","ASR","WAT","CPP","PY"],value:e,onChange:function(n){return r(n)}}),(0,l.jsx)(s.Z,{onClick:function(){navigator.clipboard.writeText(t)},style:{position:"absolute",right:"40px",top:"80px"},children:(0,l.jsx)(b.Z,{})}),(0,l.jsx)("pre",{style:{margin:"0px",height:i,overflow:"scroll",border:"1px solid black"},children:(0,l.jsx)("div",{id:"outputBox",style:{minHeight:"100%",fontSize:"0.9em",padding:"10px"},dangerouslySetInnerHTML:{__html:t}})})]})},S=t(4298),j=t.n(S),z=t(7294);function R(n,e,t,r,i,a,l){try{var o=n[a](l),u=o.value}catch(s){return void t(s)}o.done?e(u):Promise.resolve(u).then(r,i)}function D(n){return function(){var e=this,t=arguments;return new Promise((function(r,i){var a=n.apply(e,t);function l(n){R(a,r,i,l,o,"next",n)}function o(n){R(a,r,i,l,o,"throw",n)}l(void 0)}))}}function E(){return new Promise((function(n,e){Module.onRuntimeInitialized=function(){n({emit_ast_from_source:Module.cwrap("emit_ast_from_source","string",["string"]),emit_asr_from_source:Module.cwrap("emit_asr_from_source","string",["string"]),emit_wat_from_source:Module.cwrap("emit_wat_from_source","string",["string"]),emit_cpp_from_source:Module.cwrap("emit_cpp_from_source","string",["string"]),emit_py_from_source:Module.cwrap("emit_wat_from_source","string",["string"]),emit_wasm_from_source:Module.cwrap("emit_wasm_from_source","string",["string"])})}}))}function k(n,e,t){var r=function(){t(n.join("")),n.length=0};return{wasi_snapshot_preview1:{fd_write:function(e,t,r,i){var a=new DataView(T.buffer,t,2*Int32Array.BYTES_PER_ELEMENT),l=a.getInt32(0,!0),o=a.getInt32(4,!0),u=new TextDecoder("utf8").decode(new Uint8Array(T.buffer,l,o));return n.push(u),0},proc_exit:function(n){return e.val=n}},js:{cpu_time:function(n){return Date.now()/1e3},show_img:function(e,t,i){var a=new DataView(T.buffer,i,Int32Array.BYTES_PER_ELEMENT*t*e),l=document.createElement("CANVAS");l.width=e,l.height=t;for(var o=l.getContext("2d"),u=o.createImageData(e,t),s=0;s<u.data.length;s+=4)u.data[s+0]=a.getInt32(s,!0),u.data[s+1]=a.getInt32(s,!0),u.data[s+2]=a.getInt32(s,!0),u.data[s+3]=255;o.putImageData(u,0,0),n.push('<img alt="constructed image" src="'.concat(l.toDataURL("image/jpeg"),'" height="').concat(t,'" width="').concat(e,'" style="aspect-ratio: 1 / 1;"/>\n')),r()},show_img_color:function(e,t,i){var a=new DataView(T.buffer,i,4*Int32Array.BYTES_PER_ELEMENT*t*e),l=document.createElement("CANVAS");l.width=e,l.height=t;for(var o=l.getContext("2d"),u=o.createImageData(e,t),s=0;s<u.data.length;s++)u.data[s]=a.getInt32(4*s,!0);o.putImageData(u,0,0),n.push('<img alt="constructed image" src="'.concat(l.toDataURL("image/jpeg"),'" height="').concat(t,'" width="').concat(e,'" style="aspect-ratio: 1 / 1;"/>\n')),r()}}}}function q(n,e){return N.apply(this,arguments)}function N(){return N=D(a().mark((function n(e,t){var r;return a().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,E();case 2:r=n.sent,e.emit_ast_from_source=function(n){try{return r.emit_ast_from_source(n)}catch(e){return console.log(e),t(e+"\nERROR: AST could not be generated from the code"),0}},e.emit_asr_from_source=function(n){try{return r.emit_asr_from_source(n)}catch(e){return console.log(e),t(e+"\nERROR: ASR could not be generated from the code"),0}},e.emit_wat_from_source=function(n){try{return r.emit_wat_from_source(n)}catch(e){return console.log(e),t(e+"\nERROR: WAT could not be generated from the code"),0}},e.emit_cpp_from_source=function(n){try{return r.emit_cpp_from_source(n)}catch(e){return console.log(e),t(e+"\nERROR: CPP could not be generated from the code"),0}},e.emit_py_from_source=function(n){try{return r.emit_py_from_source(n)}catch(e){return console.log(e),t(e+"\nERROR: LLVM could not be generated from the code"),0}},e.compile_code=function(n){try{return r.emit_wasm_from_source(n)}catch(e){return console.log(e),t(e+"\nERROR: The code could not be compiled. Either there is a compile-time error or there is an issue at our end."),0}},e.execute_code=function(){var n=D(a().mark((function n(e,t){var r,i,l,o;return a().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return l=k(i=[],r={val:1},t),n.prev=3,n.next=6,WebAssembly.instantiate(e,l);case 6:o=n.sent,T=o.instance.exports.memory,o.instance.exports._start(),t(i.join("")),n.next=19;break;case 12:if(n.prev=12,n.t0=n.catch(3),t(i.join("")),0!=r.val){n.next=17;break}return n.abrupt("return");case 17:console.log(n.t0),t("\n".concat(n.t0,"\nERROR: The code could not be executed. Either there is a runtime error or there is an issue at our end."));case 19:case"end":return n.stop()}}),n,null,[[3,12]])})));return function(e,t){return n.apply(this,arguments)}}();case 10:case"end":return n.stop()}}),n)}))),N.apply(this,arguments)}var A=function(n){var e=n.moduleReady,t=n.setModuleReady,r=n.lfortran_funcs,i=n.openNotification,o=n.myPrint,u=n.handleUserTabChange,s=(0,z.useCallback)(D(a().mark((function n(){return a().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,q(r,o);case 2:t(!0),i("LFortran Module Initialized!","bottomRight"),console.log("LFortran Module Initialized!"),u("STDOUT");case 6:case"end":return n.stop()}}),n)}))),[e]);return(0,l.jsx)("div",{children:(0,l.jsx)(j(),{src:"./lfortran.js",onLoad:s})})};var C=t(6317),M=t(6226),P=t(1382),I=t(9614),U=t(888),Z=t(4431);function O(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}function F(n,e,t,r,i,a,l){try{var o=n[a](l),u=o.value}catch(s){return void t(s)}o.done?e(u):Promise.resolve(u).then(r,i)}function L(n){return function(){var e=this,t=arguments;return new Promise((function(r,i){var a=n.apply(e,t);function l(n){F(a,r,i,l,o,"next",n)}function o(n){F(a,r,i,l,o,"throw",n)}l(void 0)}))}}function B(n){return function(n){if(Array.isArray(n))return n}(n)||function(n){if("undefined"!==typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||function(n,e){if(!n)return;if("string"===typeof n)return O(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);"Object"===t&&n.constructor&&(t=n.constructor.name);if("Map"===t||"Set"===t)return Array.from(t);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return O(n,e)}(n,i)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}var H=new(t.n(Z)()),V=(0,l.jsx)(U.Z,{style:{fontSize:24},spin:!0}),Y=function(n,e){I.Z.info({message:n,placement:e})},W={emit_ast_from_source:null,emit_asr_from_source:null,emit_wat_from_source:null,emit_wasm_from_source:null,emit_cpp_from_source:null,emit_py_from_source:null,compile_code:null,execute_code:null};function G(){var n=(0,z.useState)(!1),e=n[0],t=n[1],r=(0,z.useState)(m.basic.mandelbrot),i=r[0],o=r[1],u=(0,z.useState)("STDOUT"),s=u[0],_=u[1],d=(0,z.useState)(""),c=d[0],p=d[1],y=function(){var n=(0,z.useState)(!1),e=n[0],t=n[1];return(0,z.useEffect)((function(){var n=function(){var n=window.innerWidth<768;t(n)};return n(),window.addEventListener("resize",n),function(){window.removeEventListener("resize",n)}}),[]),e}()?"calc(50vh - 85px)":"calc(100vh - 170px)";function f(n){return g.apply(this,arguments)}function g(){return(g=L(a().mark((function n(e){var t,r,l,o,u,s,d,c,m;return a().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if("STDOUT"!=e){n.next=19;break}if(""!==i.trim()){n.next=5;break}return p("No Source Code to compile"),_(e),n.abrupt("return");case 5:if(!(t=W.compile_code(i))){n.next=17;break}if(r=B(t.split(",")),l=r[0],o=r.slice(1),"0"===l){n.next=12;break}p(H.ansi_to_html(o)),n.next=17;break;case 12:return u=[],n.next=15,W.execute_code(new Uint8Array(o),(function(n){return u.push(n)}));case 15:n.sent,p(u.join(""));case 17:n.next=20;break;case 19:"AST"==e?(s=W.emit_ast_from_source(i))&&p(H.ansi_to_html(s)):"ASR"==e?(d=W.emit_asr_from_source(i))&&p(H.ansi_to_html(d)):"WAT"==e?(c=W.emit_wat_from_source(i))&&p(H.ansi_to_html(c)):"CPP"==e?(m=W.emit_cpp_from_source(i))&&p(H.ansi_to_html(m)):"PY"==e?p("Support for PY is not yet enabled"):(console.log("Unknown key:",e),p("Unknown key: "+e));case 20:_(e);case 21:case"end":return n.stop()}}),n)})))).apply(this,arguments)}return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(A,{moduleReady:e,setModuleReady:t,lfortran_funcs:W,openNotification:Y,myPrint:p,handleUserTabChange:f}),(0,l.jsxs)(C.Z,{gutter:[16,16],children:[(0,l.jsx)(M.Z,{xs:{span:24},sm:{span:24},md:{span:12},children:(0,l.jsx)(h,{disabled:!e,sourceCode:i,setSourceCode:o,activeTab:s,handleUserTabChange:f,myHeight:y})}),(0,l.jsx)(M.Z,{xs:{span:24},sm:{span:24},md:{span:12},children:e?(0,l.jsx)(w,{activeTab:s,output:c,handleUserTabChange:f,myHeight:y}):(0,l.jsx)("div",{style:{height:y},children:(0,l.jsx)(P.Z,{style:{position:"relative",top:"50%",left:"50%"},indicator:V})})})]})]})}}},function(n){n.O(0,[637,774,888,179],(function(){return e=5557,n(n.s=e);var e}));var e=n.O();_N_E=e}]);